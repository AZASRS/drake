% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api-plan.R
\name{drake_plan}
\alias{drake_plan}
\title{Create a workflow plan data frame
for the \code{plan} argument of \code{\link[=make]{make()}}.}
\usage{
drake_plan(..., list = character(0), file_targets = NULL,
  strings_in_dots = NULL, tidy_evaluation = TRUE, transform = TRUE,
  trace = FALSE)
}
\arguments{
\item{...}{A collection of symbols/targets
with commands assigned to them. See the examples for details.}

\item{list}{A named character vector of commands
with names as targets.}

\item{file_targets}{Deprecated.}

\item{strings_in_dots}{Deprecated.}

\item{tidy_evaluation}{Logical, whether to use tidy evaluation
such as quasiquotation
when evaluating commands passed through the free-form
\code{...} argument.}

\item{transform}{Logical, whether to transform the plan
into a larger plan with more targets.
This is still an experimental feature,
so please check your workflow with \code{vis_drake_graph()}
before running it with \code{make()}.
Requires the \code{transform} and \code{group} fields identified
by \code{target()}. See the examples for details.}

\item{trace}{Logical, whether to add columns to show
what happened during target transformations, e.g.
\code{drake_plan(x = target(..., transform = ...), transform = TRUE)}.}
}
\value{
A data frame of targets, commands, and optional
custom columns.
}
\description{
Turns a named collection of target/command pairs into
a workflow plan data frame for \code{\link[=make]{make()}}. You can give the commands
as named expressions, or you can use the \code{list}
argument to supply them as character strings.
}
\details{
A workflow plan data frame is a data frame
with a \code{target} column and a \code{command} column.
Targets are the R objects that \code{drake} generates,
and commands are the pieces of R code that produce them.

The commands that return targets may also depend on
external files and create multiple external files.
To signal that you are creating and/or depending on
custom files in your commands,
use the \code{\link[=file_in]{file_in()}}, \code{\link[=knitr_in]{knitr_in()}}, and
\code{\link[=file_out]{file_out()}} functions in your commands.
the examples in this help file provide some guidance.

Besides the \code{target} and \code{command} columns, there are optional columns
you may append to your workflow plan data frame:
\itemize{
\item \code{trigger}: a character vector of triggers. A trigger is a rule for
when to cause a target to (re)build. See \code{\link[=triggers]{triggers()}} for your options.
For a walkthrough, see
\url{https://ropenscilabs.github.io/drake-manual/debug.html}
\item \code{retries}: number of times to retry a target if it fails
to build the first time.
\item \code{timeout}: Seconds of overall time to allow before imposing
a timeout on a target.
Assign target-level timeout times with an optional \code{timeout}
column in \code{plan}.
\item \code{cpu}: Seconds of cpu time to allow before imposing
a timeout on a target.
Assign target-level cpu timeout times with an optional \code{cpu}
column in \code{plan}.
\item \code{elapsed}: Seconds of elapsed time to allow before imposing
a timeout on a target.
Assign target-level elapsed timeout times with an optional \code{elapsed}
column in \code{plan}.
\item \code{resources}: Experimental, no guarantees that this works all the time.
\code{resources} is a list column. Each element is a named list,
same as the \code{resources} argument to \code{batchtools_slurm()}
and related \code{future.bachtools} functions. See also
\url{https://github.com/HenrikBengtsson/future.batchtools#examples}. # nolint
\code{resources[[target_name]]} is a list of
computing resource parameters for the target.
Each element is a value passed to a \code{brew} placeholder of a
\code{batchtools} template file.
The list names of \code{resources[[target_name]]}
should be the brew patterns.
}
}
\examples{
test_with_dir("Contain side effects", {
# Create workflow plan data frames.
mtcars_plan <- drake_plan(
  write.csv(mtcars[, c("mpg", "cyl")], file_out("mtcars.csv")),
  value = read.csv(file_in("mtcars.csv"))
)
mtcars_plan
make(mtcars_plan) # Makes `mtcars.csv` and then `value`
head(readd(value))
# You can use knitr inputs too. See the top command below.
load_mtcars_example()
head(my_plan)
# The `knitr_in("report.Rmd")` tells `drake` to dive into the active
# code chunks to find dependencies.
# There, `drake` sees that `small`, `large`, and `coef_regression2_small`
# are loaded in with calls to `loadd()` and `readd()`.
deps_code("report.Rmd")

# Use transformations to generate large plans.
# This feature is experimental, so please
# check your workflow with `vis_drake_graph()`
# before running `make()`.
drake_plan(
  data = target(
    simulate(nrows),
    transform = map(nrows = c(48, 64))
  ),
  reg = target(
    reg_fun(data),
   transform = cross(reg_fun = c(reg1, reg2), data)
  ),
  summ = target(
    sum_fun(data, reg),
   transform = cross(sum_fun = c(coef, residuals), reg)
  ), 
  winners = target(
    min(summ),
    transform = reduce(data, sum_fun)
  )
)

# Optionally define custom groupings with the `group` field.
# Again, this is still experimental.
drake_plan(
  small = simulate(48),
  large = simulate(64),
  reg1 = target(
    reg_fun(data),
    transform = map(data = c(small, large)),
    group = reg
  ),
  reg2 = target(
    reg_fun(data),
    transform = cross(data = c(small, large)),
    group = reg
  ),
  winners = target(
    min(reg),
    transform = reduce(data),
    a = 1
  )
)

# Set `trace` to `TRUE` to retain information about the
# transformation process.
drake_plan(
  small = simulate(48),
  large = simulate(64),
  reg = target(
    reg_fun(data),
   transform = cross(reg_fun = c(reg1, reg2), data = c(small, large))
  ),
  summ = target(
    sum_fun(data, reg),
   transform = cross(sum_fun = c(coef, residuals), reg)
  ), 
  winners = target(
    min(summ),
    transform = reduce(data, sum_fun)
  ),
  trace = TRUE
)

# You can create your own custom columns too.
# See ?triggers for more on triggers.
drake_plan(
  website_data = target(
    command = download_data("www.your_url.com"),
    trigger = "always",
    custom_column = 5
  ),
  analysis = analyze(website_data)
)

# Tidy evaluation can help generate super large plans.
sms <- rlang::syms(letters) # To sub in character args, skip this.
drake_plan(x = target(f(char), transform = map(char = !!sms)))
})
}
\seealso{
\code{\link[=transform_plan]{transform_plan()}}
}
