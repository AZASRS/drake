% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workplan.R
\name{drake_plan}
\alias{drake_plan}
\title{Create a workflow plan data frame
for the \code{plan} argument of \code{\link[=make]{make()}}.}
\usage{
drake_plan(..., list = character(0), file_targets = NULL,
  strings_in_dots = pkgconfig::get_config("drake::strings_in_dots"),
  tidy_evaluation = TRUE)
}
\arguments{
\item{...}{A collection of symbols/targets
with commands assigned to them. See the examples for details.}

\item{list}{A named character vector of commands
with names as targets.}

\item{file_targets}{deprecated argument. See \code{\link[=file_out]{file_out()}},
\code{\link[=file_in]{file_in()}}, and \code{\link[=knitr_in]{knitr_in()}} for the current way to work
with files.
In the past, this argument was a logical to indicate whether the
target names should be single-quoted to denote files. But the newer
interface is much better.}

\item{strings_in_dots}{deprecated argument for handling strings in
commands specified in the \code{...} argument. Defaults to \code{NULL} for backward
compatibility. New code should use \code{\link[=file_out]{file_out()}}, \code{\link[=file_in]{file_in()}}, and
\code{\link[=knitr_in]{knitr_in()}} to specify file names and set this argument to \code{"literals"},
which will at some point become the only accepted value.

In the past, this argument was a character scalar denoting
how to treat quoted character strings in the commands
specified through \code{...}.
Set to \code{"filenames"} to treat all these strings as
external file targets/imports (single-quoted),
or to \code{"literals"} to treat them all as literal
strings (double-quoted).
Unfortunately, because of how R deparses code,
you cannot simply leave literal quotes alone in the
\code{...} argument. R will either convert all these quotes
to single quotes or double quotes. Literal quotes in the
\code{list} argument are left alone.}

\item{tidy_evaluation}{logical, whether to use tidy evaluation
such as quasiquotation
when evaluating commands passed through the free-form
\code{...} argument.}
}
\value{
A data frame of targets and commands.
}
\description{
Turns a named collection of target/command pairs into
a workflow plan data frame for \code{\link[=make]{make()}} and
\code{\link[=check]{check()}}. You can give the commands
as named expressions, or you can use the \code{list}
argument to supply them as character strings.
}
\details{
A workflow plan data frame is a data frame
with a \code{target} column and a \code{command} column.
Targets are the objects and files that drake generates,
and commands are the pieces of R code that produce them.

To use custom files in your workflow plan,
use the \code{\link[=file_in]{file_in()}}, \code{\link[=knitr_in]{knitr_in()}}, and
\code{\link[=file_out]{file_out()}} functions in your commands.
the examples in this help file provide some guidance.
}
\examples{
test_with_dir("Contain side effects", {
# Create workflow plan data frames.
mtcars_plan <- drake_plan(
  write.csv(mtcars[, c("mpg", "cyl")], file_out("mtcars.csv")),
  value = read.csv(file_in("mtcars.csv")),
  strings_in_dots = "literals"
)
mtcars_plan
make(mtcars_plan) # Makes `mtcars.csv` and then `value`
head(readd(value))
# You can use knitr inputs too. See the top command below.
load_basic_example()
head(my_plan)
# The `knitr_in("report.Rmd")` tells `drake` to dive into the active
# code chunks to find dependencies.
# There, `drake` sees that `small`, `large`, and `coef_regression2_small`
# are loaded in with calls to `loadd()` and `readd()`.
deps("report.Rmd")
# Are you a fan of tidy evaluation?
my_variable <- 1
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable")
)
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable"),
  tidy_evaluation = FALSE
)
# For instances of !! that remain unevaluated in the workflow plan,
# make() will run these commands in tidy fashion,
# evaluating the !! operator using the environment you provided.
})
}
