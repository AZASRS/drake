% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/max_useful_jobs.R
\name{max_useful_jobs}
\alias{max_useful_jobs}
\title{Suggest a ROUGH upper bound on the jobs in the next call
to \code{make(..., jobs = n)}.}
\usage{
max_useful_jobs(config = drake::read_drake_config(), imports = c("files",
  "all", "none"), from_scratch = FALSE)
}
\arguments{
\item{config}{internal configuration list of \code{\link{make}(...)},
produced also with \code{\link[=drake_config]{drake_config()}}.}

\item{imports}{Set the \code{imports} argument to change your
assumptions about how fast objects/files are imported.
Possible values:
\itemize{
\item{'all'}{: Factor all imported files/objects into
calculating the max useful number of jobs.
Note: this is not appropriate for
\code{make(.., parallelism = 'Makefile')} because imports
are processed sequentially for the Makefile option.}
\item{'files'}{: Factor all imported files into the calculation,
but ignore all the other imports.}
\item{'none'}{: Ignore all the imports and just focus on the max number
of useful jobs for parallelizing targets.}
}}

\item{from_scratch}{logical, whether to assume
the next \code{\link[=make]{make()}} will run from scratch
so that all targets are attempted.}
}
\value{
A numeric scalar, the maximum number of useful jobs for
\code{\link{make}(..., jobs = ...)}.
}
\description{
Any more jobs, and you may have too many to be useful.
Note: this is only a rough guess based on the topology of the graph.
See \code{\link[=predict_runtime]{predict_runtime()}} for a slightly better but still rough guess.
}
\examples{
\dontrun{
test_with_dir("Quarantine side effects.", {
load_mtcars_example() # Get the code with drake_example("mtcars").
config <- drake_config(my_plan) # Standard drake configuration list.
# Look at the graph. You can get an idea of how many jobs to submit
# by looking at the tallest columns.
vis_drake_graph(config = config)
# Should be 8 because everything is out of date.
max_useful_jobs(config = config) # 8
# Take into account targets and imported files.
max_useful_jobs(config = config, imports = 'files') # 8
# Include imported R objects too.
max_useful_jobs(config = config, imports = 'all') # 9
# Exclude all imported objects.
max_useful_jobs(config = config, imports = 'none') # 8
config <- make(my_plan) # Run the project, build the targets.
vis_drake_graph(config = config) # Everything is up to date.
# Ignore the targets already built.
max_useful_jobs(config = config) # 1
max_useful_jobs(config = config, imports = 'files') # 1
# Imports are never really skipped in make().
max_useful_jobs(config = config, imports = 'all') # 9
max_useful_jobs(config = config, imports = 'none') # 0
# Change a function so some targets are now out of date.
reg2 = function(d){
  d$x3 = d$x^3
  lm(y ~ x3, data = d)
}
vis_drake_graph(config = config)
# We have a different number for max useful jobs.
max_useful_jobs(config = config) # 4
# By default, max_useful_jobs() takes into account which
# targets are out of date. To assume you are building from scratch,
# consider using the "always" trigger.
max_useful_jobs(config, from_scratch = TRUE, imports = 'files') # 8
max_useful_jobs(config, from_scratch = TRUE, imports = 'all') # 9
max_useful_jobs(config, from_scratch = TRUE, imports = 'none') # 8
})
}
}
\seealso{
\code{\link[=predict_runtime]{predict_runtime()}}, \code{\link[=vis_drake_graph]{vis_drake_graph()}}, \code{\link[=build_drake_graph]{build_drake_graph()}},
\code{\link[=shell_file]{shell_file()}}, \code{\link[=drake_config]{drake_config()}}
}
