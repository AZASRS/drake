% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict_runtime.R
\name{predict_runtime}
\alias{predict_runtime}
\title{Predict the elapsed runtime of the next call to \code{make()}.}
\usage{
predict_runtime(config = drake::read_drake_config(), targets = NULL,
  from_scratch = FALSE, targets_only = FALSE, future_jobs = NULL,
  digits = NULL, jobs = 1, known_times = numeric(0), default_time = 0)
}
\arguments{
\item{config}{option internal runtime parameter list of
\code{\link{make}(...)},
produced by both \code{\link[=make]{make()}} and
\code{\link[=drake_config]{drake_config()}}.}

\item{targets}{Character vector, names of targets.
Predict the runtime of building these targets
plus dependencies.
Defaults to all targets.}

\item{from_scratch}{logical, whether to predict a
\code{\link[=make]{make()}} build from scratch or to
take into account the fact that some targets may be
already up to date and therefore skipped.}

\item{targets_only}{logical, whether to factor in
just the targets into the calculations or use the
build times for everything, including the imports}

\item{future_jobs}{deprecated}

\item{digits}{deprecated}

\item{jobs}{the \code{jobs} argument of your next planned
\code{make()}. How many targets to do you plan
to have running simultaneously?}

\item{known_times}{a named numeric vector with targets/imports
as names and values as hypothetical runtimes in seconds.
Use this argument to overwrite any of the existing build times
or the \code{default_time}.}

\item{default_time}{number of seconds to assume for any
target or import with no recorded runtime (from \code{\link[=build_times]{build_times()}})
or anything in \code{known_times}.}
}
\value{
Simulated runtimes. This is a single \code{lubridate} duration
(seconds) if \code{jobs} is 1 and a vector if \code{jobs} is any larger.
}
\description{
Take the past recorded runtimes times from
\code{\link[=build_times]{build_times()}} and use them to predict how the targets
will be distributed among the available workers in the
next \code{\link[=make]{make()}}. Then, predict the overall runtime to be the
runtime of the slowest (busiest) workers. See Details for some
caveats.
}
\details{
The prediction is only a rough approximation. It assumes
that the overhead of initializing \code{\link[=make]{make()}} and any workers is
negligible. Use the \code{default_time} and \code{known_times} arguments
to adjust the assumptions as needed.
}
\examples{
\dontrun{
test_with_dir("Quarantine side effects.", {
load_mtcars_example() # Get the code with drake_example("mtcars").
config <- make(my_plan) # Run the project, build the targets.
predict_runtime(config, from_scratch = TRUE) # 1 job
# Assumes you clean() out your project and start from scratch with 2 jobs.
predict_runtime(config, jobs = 4, from_scratch = TRUE)
# Predict the runtime of just building targets
# "small" and "large".
predict_runtime(
  config,
  targets = c("small", "large"),
  from_scratch = TRUE
)
})
}
}
\seealso{
\code{\link[=build_times]{build_times()}}, \code{\link[=make]{make()}}
}
