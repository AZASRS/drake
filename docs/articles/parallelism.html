<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>High-performance computing with drake • drake</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="High-performance computing with drake">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">drake</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">5.1.3.9001</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/drake.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/faq.html">FAQ</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/example-packages.html">Example: R package download trends</a>
    </li>
    <li>
      <a href="../articles/example-gsp.html">Example: gross state products</a>
    </li>
    <li>
      <a href="../articles/example-mtcars.html">Example: mtcars and workflow plan generation</a>
    </li>
    <li>
      <a href="../articles/best-practices.html">General best practices for drake projects</a>
    </li>
    <li>
      <a href="../articles/debug.html">Debugging and testing drake projects</a>
    </li>
    <li>
      <a href="../articles/graph.html">Graphs with drake</a>
    </li>
    <li>
      <a href="../articles/parallelism.html">Parallel computing</a>
    </li>
    <li>
      <a href="../articles/timing.html">Timing: logging, prediction, and strategy</a>
    </li>
    <li>
      <a href="../articles/storage.html">Storage</a>
    </li>
    <li>
      <a href="../articles/caution.html">Caution</a>
    </li>
    <li>
      <a href="../articles/faq.html">Frequently-asked questions</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/ropensci/drake">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>High-performance computing with drake</h1>
                        <h4 class="author">Will Landau</h4>
            
            <h4 class="date">2018-05-13</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/ropensci/drake/blob/master/vignettes/parallelism.Rmd"><code>vignettes/parallelism.Rmd</code></a></small>
      <div class="hidden name"><code>parallelism.Rmd</code></div>

    </div>

    
    
<p><code>Drake</code> is not only a reproducibility tool, but also a high-performance computing engine. To activate parallel computing, just set the <code>jobs</code> argument of <code><a href="../reference/make.html">make()</a></code> to a value greater than 1. Below, up to 2 targets can run simultaneously at any given time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(drake)
<span class="kw"><a href="../reference/load_mtcars_example.html">load_mtcars_example</a></span>()
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>To deploy serious long workflows, we recommend putting the call to <code><a href="../reference/make.html">make()</a></code> in a script (say, <code>make.R</code>) and running it in an unobtrusive background process that persists after you log out. In the Linux command line, this is straightforward.</p>
<pre><code>nohup nice -19 R CMD BATCH make.R &amp;
</code></pre>
<p>When you deploy your project, <code>drake</code> uses the dependency network to figure out how to run your work in parallel. You as the user do not have to micromanage when individual targets are built.</p>
<iframe src="https://ropensci.github.io/drake/images/outdated.html" width="100%" height="600px" allowtransparency="true" style="border: none; box-shadow: none">
</iframe>
<p>There are multiple ways to walk this graph and multiple ways to launch workers, and every project has its own needs. Thus, <code>drake</code> supports multiple parallel backends. Choose the backend with the <code>parallelism</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"parLapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>List your options with <code><a href="../reference/parallelism_choices.html">parallelism_choices()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parallelism_choices.html">parallelism_choices</a></span>()
## [1] "mclapply"         "parLapply"        "mclapply_staged" 
## [4] "parLapply_staged" "future"           "future_lapply"   
## [7] "Makefile"</code></pre></div>
<p>The backends vary widely in terms of how the workers deploy and how they are scheduled.</p>
<table class="table">
<thead><tr class="header">
<th align="left"></th>
<th align="center">Deploy: local</th>
<th align="right">Deploy: remote</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Schedule: persistent</td>
<td align="center">“mclapply”, “parLapply”</td>
<td align="right">“future_lapply”</td>
</tr>
<tr class="even">
<td align="left">Schedule: transient</td>
<td align="center"></td>
<td align="right">“future”, “Makefile”</td>
</tr>
<tr class="odd">
<td align="left">Schedule: staged</td>
<td align="center">“mclapply_staged”, “parLapply_staged”</td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p>The next sections describe how and when to use each scheduling algorithm and deployment strategy.</p>
<div id="local-workers" class="section level1">
<h1 class="hasAnchor">
<a href="#local-workers" class="anchor"></a>Local workers</h1>
<p>Local workers deploy as separate forks or processes to you computer. The <code>"mclapply"</code> and <code>"mclapply_staged"</code> backends uses the <code>mclapply()</code> function from the <code>parallel</code> package to launch workers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"mclapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"mclapply_staged"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>Workers are quicker to launch than in any other <code>drake</code> backend, so these two choices are the lowest-overhead options. However, they have limitations: the <code>mclapply()</code> function is inefficient with respect to computer memory (see explanations <a href="https://github.com/tdhock/mclapply-memory">here</a> and <a href="http://lcolladotor.github.io/2013/11/14/Reducing-memory-overhead-when-using-mclapply/#.Wu8Fc9Yh1hE">here</a>) and it cannot launch multiple workers on Windows. For this reason, <code>drake</code> supports platform agnostic backends <code>"parLapply"</code> and <code>"parLapply_staged"</code>, both of which are based on the <code>parLapply()</code> function from the <code>parallel</code> package. These options work on Windows, but each <code><a href="../reference/make.html">make()</a></code> requires extra overhead to create a <a href="http://gforge.se/2015/02/how-to-go-parallel-in-r-basics-tips/">parallel socket (PSOCK) cluster</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"parLapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"parLapply_staged"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>The default parallelism is <code>"parLapply"</code> on Windows and <code>"mclapply"</code> everywhere else.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/default_parallelism.html">default_parallelism</a></span>()
## [1] "mclapply"</code></pre></div>
</div>
<div id="remote-workers" class="section level1">
<h1 class="hasAnchor">
<a href="#remote-workers" class="anchor"></a>Remote workers</h1>
<p>The <code>"future_lapply"</code>, <code>"future"</code>, and <code>"Makefile"</code> backends have the option to launch workers to remote resources such as nodes on a computing cluster.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parallelism_choices.html">parallelism_choices</a></span>(<span class="dt">distributed_only =</span> <span class="ot">TRUE</span>)
## [1] "future"        "future_lapply" "Makefile"</code></pre></div>
<p>Testing them out is straightforward.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future_lapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>For remote workers, the all the imports are processed with one of the local worker backends before any of the targets start. You can use different numbers of workers for the imports and the targets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future"</span>, <span class="dt">jobs =</span> <span class="kw">c</span>(<span class="dt">imports =</span> <span class="dv">2</span>, <span class="dt">targets =</span> <span class="dv">4</span>))</code></pre></div>
<p>By default, these backends launch the workers on your local machine. It takes extra configuring to actually deploy them to a remote cluster. The next subsections have the details.</p>
<div id="future-and-future_lapply" class="section level2">
<h2 class="hasAnchor">
<a href="#future-and-future_lapply" class="anchor"></a><code>"future"</code> and <code>"future_lapply"</code>
</h2>
<p>The <code><a href="../reference/plan.html">plan()</a></code> function from the <a href="https://github.com/HenrikBengtsson/future"><code>future</code></a> package configures how and where the workers will deploy on the next <code><a href="../reference/make.html">make()</a></code>. For example, the following code uses <a href="https://github.com/HenrikBengtsson/future"><code>future</code></a>’s <code>multisession</code> backend, which is analogous to <code>drake</code>’s <code>"parLapply"</code> parallelism.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(future)
future::<span class="kw"><a href="../reference/plan.html">plan</a></span>(multisession)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="co"># Same technology, different scheduling:</span>
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future_lapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>To deploy to a cluster (say, a <a href="https://slurm.schedmd.com/">SLURM</a> cluster), you need the <a href="https://github.com/mllg/batchtools"><code>batchtools</code></a> and <a href="https://github.com/HenrikBengtsson/future.batchtools"><code>future.batchtools</code></a> packages.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(future.batchtools)</code></pre></div>
<p>You also need <a href="https://github.com/mllg/batchtools/tree/master/inst/templates">template file</a> to configure <a href="https://github.com/mllg/batchtools"><code>batchtools</code></a> the remote resources, such as the memory and wall time limits. Use <code><a href="../reference/drake_batchtools_tmpl_file.html">drake_batchtools_tmpl_file()</a></code> to write one of the examples from the <a href="https://github.com/ropensci/drake/tree/master/inst/examples"><code><a href="../reference/drake_example.html">drake_example()</a></code> files</a>. You will probably need to edit it manually to match your resources and needs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/drake_batchtools_tmpl_file.html">drake_batchtools_tmpl_file</a></span>(<span class="st">"slurm"</span>) <span class="co"># Write batchtools.slurm.tmpl.</span></code></pre></div>
<p>Load the template file your <code><a href="http://www.rdocumentation.org/packages/future/topics/plan">future::plan()</a></code> and call <code><a href="../reference/make.html">make()</a></code> to run the project.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">future::<span class="kw"><a href="../reference/plan.html">plan</a></span>(batchtools_slurm, <span class="dt">template =</span> <span class="st">"batchtools.slurm.tmpl"</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="co"># Same technology, different scheduling:</span>
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future_lapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>See packages <a href="https://github.com/HenrikBengtsson/future"><code>future</code></a>, <a href="https://github.com/HenrikBengtsson/future.batchtools"><code>future.batchtools</code></a>, and <a href="https://github.com/mllg/batchtools"><code>batchtools</code></a> for more options. For example, the alternatives for <code><a href="http://www.rdocumentation.org/packages/future/topics/plan">future::plan()</a></code> are listed <a href="https://github.com/HenrikBengtsson/future#controlling-how-futures-are-resolved">here</a> and <a href="https://github.com/HenrikBengtsson/future.batchtools#choosing-batchtools-backend">here</a>.</p>
</div>
<div id="makefile" class="section level2">
<h2 class="hasAnchor">
<a href="#makefile" class="anchor"></a><code>"Makefile"</code>
</h2>
<p>Here, <code>drake</code> actually writes, configures, and runs a proper <a href="https://www.gnu.org/software/make/"><code>Makefile</code></a> to run the targets.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>You can configure both the Unix command that runs the <a href="https://www.gnu.org/software/make/"><code>Makefile</code></a> and the command line arguments passed to it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(
  my_plan,
  <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>,
  <span class="dt">command =</span> <span class="st">"lsmake"</span>,
  <span class="dt">args =</span> <span class="kw">c</span>(<span class="st">"--touch"</span>, <span class="st">"--silent"</span>)
)</code></pre></div>
<p>There are more customization options in <code><a href="../reference/make.html">make()</a></code>, such as the <code>recipe_command</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>, <span class="dt">jobs =</span> <span class="dv">4</span>,
  <span class="dt">recipe_command =</span> <span class="st">"R -e 'R_RECIPE' -q"</span>)</code></pre></div>
<p>See the help files of individual functions for details.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/default_Makefile_command.html">default_Makefile_command</a></span>()
## [1] "make"

<span class="kw"><a href="../reference/default_recipe_command.html">default_recipe_command</a></span>()
## [1] "Rscript -e 'R_RECIPE'"

<span class="kw"><a href="../reference/r_recipe_wildcard.html">r_recipe_wildcard</a></span>()
## [1] "R_RECIPE"

<span class="kw"><a href="../reference/Makefile_recipe.html">Makefile_recipe</a></span>(
  <span class="dt">recipe_command =</span> <span class="st">"R -e 'R_RECIPE' -q"</span>,
  <span class="dt">target =</span> <span class="st">"this_target"</span>,
  <span class="dt">cache_path =</span> <span class="st">"custom_cache"</span>
)
## R -e 'drake::mk(target = "this_target", cache_path = "custom_cache")' -q</code></pre></div>
<p>To deploy workers to a cluster, you need to supply the <a href="https://www.gnu.org/software/make/"><code>Makefile</code></a> with a custom shell script that launches cluster jobs. Use the <code><a href="../reference/shell_file.html">shell_file()</a></code> function to write an example compatible with the <a href="http://www.univa.com/products/">Univa Grid Engine</a>. You will probably need to configure it manually. Suppose our file is <code>shell.sh</code>.</p>
<pre><code>#!/bin/bash
shift
echo "module load R; $*" | qsub -sync y -cwd -j y
</code></pre>
<p>You will need to set permissions to allow execution. In the Linux command line, this is straightforward.</p>
<pre><code>$ chmod +x shell.sh 
</code></pre>
<p>When you actually call <code><a href="../reference/make.html">make()</a></code>, use the <code>prepend</code> argument to write a line at the top of the <a href="https://www.gnu.org/software/make/"><code>Makefile</code></a> to reference your shell file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>, <span class="dt">prepend =</span> <span class="st">"SHELL=./shell.sh"</span>)</code></pre></div>
<p><a href="https://slurm.schedmd.com/">SLURM</a> users may be able to <a href="http://plindenbaum.blogspot.com/2014/09/parallelizing-gnu-make-4-in-slurm.html">invoke <code>srun</code> and dispense with <code>shell.sh</code> altogether</a>, though success may vary depending on the SLURM system. You will probably also need to set resource allocation parameters governing memory, runtime, etc. See <code>man srun</code> for the possible <code>.SHELLFLAGS</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(
  my_plan,
  <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>,
  <span class="dt">jobs =</span> <span class="dv">2</span>,
  <span class="dt">prepend =</span> <span class="kw">c</span>(
    <span class="st">"SHELL=srun"</span>,
    <span class="st">".SHELLFLAGS=-N1 -n1 bash -c"</span>
  )
)</code></pre></div>
</div>
</div>
<div id="scheduling-algorithms" class="section level1">
<h1 class="hasAnchor">
<a href="#scheduling-algorithms" class="anchor"></a>Scheduling algorithms</h1>
<div id="persistent-scheduling" class="section level2">
<h2 class="hasAnchor">
<a href="#persistent-scheduling" class="anchor"></a>Persistent scheduling</h2>
<p>Backends “mclapply”, “parLapply”, and “future_lapply” launch persistent workers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"mclapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"parLapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
future::<span class="kw"><a href="../reference/plan.html">plan</a></span>(future::multisession)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future_lapply"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>In each of these calls to <code><a href="../reference/make.html">make()</a></code>, three processes launch: two workers and one master. Whenever a worker is idle, the master assigns it the next available target (whose dependencies have been built). The workers keep running until there are no more targets to build. The following video demonstrates the concept.</p>
<iframe width="640" height="360" src="https://www.powtoon.com/embed/fsHPN0DTn5i/" frameborder="0">
</iframe>
<p>The <code><a href="../reference/predict_runtime.html">predict_runtime()</a></code> and <code><a href="../reference/predict_load_balancing.html">predict_load_balancing()</a></code> functions emulate persistent workers, and the predictions also apply to transient workers. See the <a href="https://ropensci.github.io/drake/articles/timing.html">timing guide</a> for a demonstration.</p>
</div>
<div id="transient-scheduling" class="section level2">
<h2 class="hasAnchor">
<a href="#transient-scheduling" class="anchor"></a>Transient scheduling</h2>
<p>Persistent workers are great because they minimize overhead: all the workers are created at the beginning, and then you never have to create any more for the rest of the runthrough. Unfortunately, computing clusters usually limit the amount of time each worker can stay running. That is why <code>drake</code> also supports transient workers in backends <code>"future"</code> and <code>"Makefile"</code>. Here, the master process creates a new worker for each target individually, and the worker dies after it finishes its single target. For the <code>"future"</code> backend, the master is just the existing process calling <code><a href="../reference/make.html">make()</a></code>. The following video demonstrates the concept.</p>
<iframe width="640" height="360" src="https://www.powtoon.com/embed/dPTubZwZqtx/" frameborder="0">
</iframe>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">future::<span class="kw"><a href="../reference/plan.html">plan</a></span>(future::multisession)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"future"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"Makefile"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
</div>
<div id="staged-scheduling" class="section level2">
<h2 class="hasAnchor">
<a href="#staged-scheduling" class="anchor"></a>Staged scheduling</h2>
<p>Backends <code>"mclapply_staged"</code> and <code>"parLapply_staged"</code> support staged scheduling.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"mclapply_staged"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">parallelism =</span> <span class="st">"parLapply_staged"</span>, <span class="dt">jobs =</span> <span class="dv">2</span>)</code></pre></div>
<p>Here, the dependency network is divided into separate stages of conditionally independent targets. Within each stage, <code>drake</code> uses <code>mclapply()</code> or <code>parLapply()</code> to process the targets in parallel. Stages run one after the other, so the slowest target in the current stage needs to complete before the next stage begins. So we lose a lot of parallel efficiency. The following video demonstrates the major drawback.<sup><a href="#note1" id="note1ref">[1]</a></sup></p>
<iframe width="640" height="360" src="https://www.powtoon.com/embed/fkwJXrmh0hz/" frameborder="0">
</iframe>
<p>However, because there is no formal master process in each stage, overhead is extremely low. This lack of overhead can make staged parallelism a great choice for projects with a small number of large stages: tall dependency graphs with most of the work in the tallest stages.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">library</span>(drake)

N &lt;-<span class="st"> </span><span class="dv">500</span>

gen_data &lt;-<span class="st"> </span>function() {
  <span class="kw"><a href="http://dplyr.tidyverse.org/reference/reexports.html">tibble</a></span>(<span class="dt">a =</span> <span class="kw">seq_len</span>(N), <span class="dt">b =</span> <span class="dv">1</span>, <span class="dt">c =</span> <span class="dv">2</span>, <span class="dt">d =</span> <span class="dv">3</span>)
}

plan_data &lt;-<span class="st"> </span><span class="kw"><a href="../reference/drake_plan.html">drake_plan</a></span>(
  <span class="dt">data =</span> <span class="kw">gen_data</span>()
)

plan_sub &lt;-
<span class="st">  </span><span class="kw">gen_data</span>() %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/mutate.html">transmute</a></span>(
    <span class="dt">target =</span> <span class="kw">paste0</span>(<span class="st">"data"</span>, a),
    <span class="dt">command =</span> <span class="kw">paste0</span>(<span class="st">"data["</span>, a, <span class="st">", ]"</span>)
  )

plan &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/bind.html">bind_rows</a></span>(plan_data, plan_sub)
plan
## # A tibble: 501 x 2
##    target command   
##    &lt;chr&gt;  &lt;chr&gt;     
##  1 data   gen_data()
##  2 data1  data[1, ] 
##  3 data2  data[2, ] 
##  4 data3  data[3, ] 
##  5 data4  data[4, ] 
##  6 data5  data[5, ] 
##  7 data6  data[6, ] 
##  8 data7  data[7, ] 
##  9 data8  data[8, ] 
## 10 data9  data[9, ] 
## # ... with 491 more rows</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">config &lt;-<span class="st"> </span><span class="kw"><a href="../reference/drake_config.html">drake_config</a></span>(plan)
<span class="kw"><a href="../reference/vis_drake_graph.html">vis_drake_graph</a></span>(plan)</code></pre></div>
<iframe src="https://ropensci.github.io/drake/images/staged.html" width="100%" height="600px" allowtransparency="true" style="border: none; box-shadow: none">
</iframe>
</div>
</div>
<div id="final-thoughts" class="section level1">
<h1 class="hasAnchor">
<a href="#final-thoughts" class="anchor"></a>Final thoughts</h1>
<div id="debugging" class="section level2">
<h2 class="hasAnchor">
<a href="#debugging" class="anchor"></a>Debugging</h2>
<p>For large workflows, downsizing and debugging tools become super important. See the <a href="https://github.com/ropensci/drake/blob/master/vignettes/debug.Rmd">“debug” vignette</a> for help on diagnosing problems with a workflow. <a href="https://github.com/ropensci/drake/blob/master/vignettes/debug.Rmd#test-with-triggers">Triggers</a> and <a href="https://github.com/ropensci/drake/blob/master/vignettes/debug.Rmd#diagnose-failures">cached error logs</a> especially speed the development and testing process.</p>
</div>
<div id="drake-as-an-ordinary-job-scheduler" class="section level2">
<h2 class="hasAnchor">
<a href="#drake-as-an-ordinary-job-scheduler" class="anchor"></a>Drake as an ordinary job scheduler</h2>
<p>If you do not care about reproducibility and you want <code>drake</code> to be an ordinary job scheduler, consider using <a href="https://github.com/ropensci/drake/blob/master/vignettes/debug.Rmd#test-with-triggers">alternative triggers</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/load_mtcars_example.html">load_mtcars_example</a></span>()
<span class="kw"><a href="../reference/make.html">make</a></span>(my_plan, <span class="dt">trigger =</span> <span class="st">"missing"</span>) <span class="co"># Also consider "always".</span></code></pre></div>
<p>Above, <code>drake</code> only builds the missing targets. This skips much of the <a href="https://github.com/ropensci/drake/blob/master/vignettes/storage.Rmd#hash-algorithms">time-consuming hashing</a> that ordinarily detects which targets are out of date.</p>
</div>
<div id="more-resources" class="section level2">
<h2 class="hasAnchor">
<a href="#more-resources" class="anchor"></a>More resources</h2>
<p>See the <a href="https://github.com/ropensci/drake/blob/master/vignettes/timing.Rmd">timing vignette</a> for explanations of functions <code><a href="../reference/predict_runtime.html">predict_runtime()</a></code> and <code><a href="../reference/predict_load_balancing.html">predict_load_balancing()</a></code>, which can help you plan and strategize deployment.</p>
</div>
</div>
<div id="footnotes" class="section level1">
<h1 class="hasAnchor">
<a href="#footnotes" class="anchor"></a>Footnotes</h1>
<p><a id="note1" href="#note1ref">[1]</a> The video of staged parallelism is an oversimplification. It holds mostly true for <code><a href="../reference/make.html">make(parallelism = "parLapply_staged")</a></code>, but <code><a href="../reference/make.html">make(parallelism = "mclapply_staged")</a></code> is a bit different. In the former case, each stage is a call to <code>parLapply()</code>, which recycles existing workers on a pre-built parallel socket (PSOCK) cluster. But in the latter, every stage is a new call to <code>mclapply()</code>, which launches a brand new batch of workers. In that sense, workers in <code><a href="../reference/make.html">make(parallelism = "parLapply_staged")</a></code> are sort of persistent, and workers in <code><a href="../reference/make.html">make(parallelism = "mclapply_staged")</a></code> are sort of transient for some projects.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#local-workers">Local workers</a></li>
      <li>
<a href="#remote-workers">Remote workers</a><ul class="nav nav-pills nav-stacked">
<li><a href="#future-and-future_lapply"><code>"future"</code> and <code>"future_lapply"</code></a></li>
      <li><a href="#makefile"><code>"Makefile"</code></a></li>
      </ul>
</li>
      <li>
<a href="#scheduling-algorithms">Scheduling algorithms</a><ul class="nav nav-pills nav-stacked">
<li><a href="#persistent-scheduling">Persistent scheduling</a></li>
      <li><a href="#transient-scheduling">Transient scheduling</a></li>
      <li><a href="#staged-scheduling">Staged scheduling</a></li>
      </ul>
</li>
      <li>
<a href="#final-thoughts">Final thoughts</a><ul class="nav nav-pills nav-stacked">
<li><a href="#debugging">Debugging</a></li>
      <li><a href="#drake-as-an-ordinary-job-scheduler">Drake as an ordinary job scheduler</a></li>
      <li><a href="#more-resources">More resources</a></li>
      </ul>
</li>
      <li><a href="#footnotes">Footnotes</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by William Michael Landau.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
